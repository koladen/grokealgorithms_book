Массивы и связные списки.

Массивы хранят свои элементы подряд. Если мы пытаемся вставить новый элемент в конец, а свободной ячейки нет, то нужно
выделить необходимое место, и перенести все элементы в это новое место. Т.к. выделяются элементы с запасом, то это
происходит не очень часто.
Если элемент вставляется в середину, от нужно скопировать все элементы после вставляемого O(n).
Доступ к элементу массива по индексу происходит за время О(1), т.к. мы точно знаем, по какому адресу находится элемент.
Удалять элемент из начала или середины не эффективно, т.к. копируется весь список элементов.

В связных списках элементы разбросаны по всей памяти, т.к. каждый предыдущий элемент ссылается на последующий.
Соотвественно память расходуется эффективнее, и добавлять элемент в конец списка быстрее в среднем О(1)

Поиск в связных списках проиходит медленнее чем в массивах, т.к. мы не знаем точный адрес элемента, мы вынуждены
пройтись по всем элементам, чтобы найти следующий. Время О(n)
Удаление элемента происходит путем пересвязывания элементов, т.е. происходит  быстро

Массивы поддерживают произвольный доступ, а списки - последовательный

Пример сортировки выбором:

def find_smallest(arr):
    smallest = arr[0]
    smal_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smal_index = i
    return smal_index


def my_sort(arr):
    new_arr = []
    for i in range(len(arr)):
        new_arr.append(arr.pop(find_smallest(arr)))

    return new_arr